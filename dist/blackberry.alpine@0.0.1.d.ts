// Generated by dts-bundle-generator v9.5.1

declare enum TrackOpTypes {
	GET = "get",
	HAS = "has",
	ITERATE = "iterate"
}
declare enum TriggerOpTypes {
	SET = "set",
	ADD = "add",
	DELETE = "delete",
	CLEAR = "clear"
}
export type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>;
declare const ReactiveMarkerSymbol: unique symbol;
export interface ReactiveMarker {
	[ReactiveMarkerSymbol]?: void;
}
export type Reactive<T> = UnwrapNestedRefs<T> & (T extends readonly any[] ? ReactiveMarker : {});
declare function reactive<T extends object>(target: T): Reactive<T>;
declare const ShallowReactiveMarker: unique symbol;
export type Primitive = string | number | boolean | bigint | symbol | undefined | null;
export type Builtin = Primitive | Function | Date | Error | RegExp;
export type EffectScheduler = (...args: any[]) => any;
export type DebuggerEvent = {
	effect: Subscriber;
} & DebuggerEventExtraInfo;
export type DebuggerEventExtraInfo = {
	target: object;
	type: TrackOpTypes | TriggerOpTypes;
	key: any;
	newValue?: any;
	oldValue?: any;
	oldTarget?: Map<any, any> | Set<any>;
};
export interface DebuggerOptions {
	onTrack?: (event: DebuggerEvent) => void;
	onTrigger?: (event: DebuggerEvent) => void;
}
export interface ReactiveEffectOptions extends DebuggerOptions {
	scheduler?: EffectScheduler;
	allowRecurse?: boolean;
	onStop?: () => void;
}
/**
 * Subscriber is a type that tracks (or subscribes to) a list of deps.
 */
export interface Subscriber extends DebuggerOptions {
}
declare class ReactiveEffect<T = any> implements Subscriber, ReactiveEffectOptions {
	fn: () => T;
	scheduler?: EffectScheduler;
	onStop?: () => void;
	onTrack?: (event: DebuggerEvent) => void;
	onTrigger?: (event: DebuggerEvent) => void;
	constructor(fn: () => T);
	pause(): void;
	resume(): void;
	run(): T;
	stop(): void;
	trigger(): void;
	get dirty(): boolean;
}
export interface ReactiveEffectRunner<T = any> {
	(): T;
	effect: ReactiveEffect;
}
export interface ReactiveEffectRunner<T = any> {
	(): T;
	effect: ReactiveEffect;
}
declare function effect<T = any>(fn: () => T, options?: ReactiveEffectOptions): ReactiveEffectRunner<T>;
declare const RefSymbol: unique symbol;
declare const RawSymbol: unique symbol;
export interface Ref<T = any, S = T> {
	get value(): T;
	set value(_: S);
	/**
	 * Type differentiator only.
	 * We need this to be in public d.ts but don't want it to show up in IDE
	 * autocomplete, so we use a private Symbol instead.
	 */
	[RefSymbol]: true;
}
declare const ShallowRefMarker: unique symbol;
export type ShallowRef<T = any, S = T> = Ref<T, S> & {
	[ShallowRefMarker]?: true;
};
/**
 * This is a special exported interface for other packages to declare
 * additional types that should bail out for ref unwrapping. For example
 * \@vue/runtime-dom can declare it like so in its d.ts:
 *
 * ``` ts
 * declare module '@vue/reactivity' {
 *   export interface RefUnwrapBailTypes {
 *     runtimeDOMBailTypes: Node | Window
 *   }
 * }
 * ```
 */
export interface RefUnwrapBailTypes {
}
export type UnwrapRef<T> = T extends ShallowRef<infer V, unknown> ? V : T extends Ref<infer V, unknown> ? UnwrapRefSimple<V> : UnwrapRefSimple<T>;
export type UnwrapRefSimple<T> = T extends Builtin | Ref | RefUnwrapBailTypes[keyof RefUnwrapBailTypes] | {
	[RawSymbol]?: true;
} ? T : T extends Map<infer K, infer V> ? Map<K, UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Map<any, any>>> : T extends WeakMap<infer K, infer V> ? WeakMap<K, UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof WeakMap<any, any>>> : T extends Set<infer V> ? Set<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof Set<any>>> : T extends WeakSet<infer V> ? WeakSet<UnwrapRefSimple<V>> & UnwrapRef<Omit<T, keyof WeakSet<any>>> : T extends ReadonlyArray<any> ? {
	[K in keyof T]: UnwrapRefSimple<T[K]>;
} : T extends object & {
	[ShallowReactiveMarker]?: never;
} ? {
	[P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>;
} : T;
declare class VNode {
}
declare abstract class BlackberryElement extends HTMLElement {
	static styles: string;
	static useGlobalStyles: boolean;
	static DefineElement(name: string): void;
	attrs: Record<string, string>;
	abstract render(): VNode;
	onMount?(): void;
	onUnmount?(): void;
}
export declare type ReactiveInput = {
	effect: typeof effect;
	reactive: typeof reactive;
};
declare const _default: {
	alpinePlugin: (alpine: any) => void;
	CreateBlackberryElement: (reactivity: ReactiveInput) => typeof BlackberryElement;
	h: (tag: string, props: Record<string, any> | VNode | string | number, ...children: any[]) => VNode;
	text: (value: string | number) => VNode;
	css: (strings: TemplateStringsArray, ...values: string[]) => string;
	elementFactory: (tag: string) => (props: Record<string, any>, ...children: any[]) => VNode;
	state: <This, T>(value: ClassAccessorDecoratorTarget<This, T>, context: ClassAccessorDecoratorContext<This, T>) => void;
	attribute: <This, T>(value: ClassAccessorDecoratorTarget<This, T>, context: ClassAccessorDecoratorContext<This, T>) => void;
};

export {
	_default as default,
};

export {};
